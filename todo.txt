add more checks to arg parsing

start thinking about how to combine alignments from the Pareto front
to create local ones. Should try to take from the best representatives of
the whole front-- might want to look at distance in alignment space as well
as objective space to do so.

add logging of mean and max over time for plotting purposes

make sure asserts are turned off in optimized version

consider adding archive

consider self-adaptive mutation probabilities

there is some kind of bug in fastICS when the networks contain self-loops.
	This can cause fastICS to under or over estimate ICS when there are 
	a lot of self-loops. Currently, ignoring self-loops when reading 
	networks, but that causes a couple ICS tests to fail (since they 
	are comparing against ICS computations that don't ignore self-loops).
	So, those tests are commented out.
	In the long run, it would be good to fix this bug, but it is taking
	an inordinate amount of time right now.

write tests for v1Unaligned being correct after all modifying ops.

consider abandoning size optimization if total alignment optimization
performance continues to be much better. Instead, might want to do partiality
as a post-processing step of extracting high-confidence sub-alignments.

add the ability to specify a list of fitnesses to dominate as a stopping condition.
Maybe go another 10000 generations after dominating the last one.

add seed-and-extend with random restart

add GOC as an objective-- that could get us to competitive results much faster and more reliably.

add an alternative crowding distance calculator that uses alignment space distances

REFACTORING
-----------

rewrite the abomination that updateConservedCount has become.
Function of: whether self loop, whether neighbor and self used to have
       conserved edge, whether neighbor and self now have conserved
       edge, and both masks. 


LOCAL SEARCH ALONE
------------------
Alternating between optimizing ICS/EC and bitscore sum each iteration. This seems
to get to an EC of about .15 really quickly on dm-hs, but then it starts to slowly fall. This isn't bad, but it's a lot worse than it could be given the GA performance. Bitscore sum, OTOH, increases very slowly compared to other methods but seems to keep increasing for much longer compared to topological fit. Also, it could be that this way of trying to compromise between the two objectives simply doesn't work well.

SEEDING
-------
After seeding, the GA portion of the program appears to go much more slowly than otherwise, although the diversity of the results is much better. It could be that the hillclimbers all found their own hills and the space between them is completely flat, so combining them isn't helping much. Unfortunately, though, it seems bitscore sum is not increasing much either, even though we are also seeding with a greedy matching based on bitscore.